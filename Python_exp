1. Python 中没有变量声明的过程，使用时直接初始化（声明+赋值），以为Python是以真实值为基准，而变量名是指向该值的指针。

2. 可更改(mutable)与不可更改(immutable)对象
1) 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
(1) 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
(2) 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
2) python 函数的参数传递：
(1) 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。
    比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
(2) 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响
3) python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

3. 什么是可变/不可变对象
1) 不可变对象，该对象所指向的内存中的值不能被改变。
当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。
2) 可变对象，该对象所指向的内存中的值可以被改变。
变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。
3) Python中，数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。

4. 序列 & 字典
序列是以连续的整数为索引，如列表，元组。
字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
(1) 理解字典的最佳方式是把它看做无序的键=>值对集合。
(2) 在同一个字典之内，关键字必须是互不相同。
(3) 一对大括号创建一个空的字典：{}。

5. 参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。
但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
比如定义一个函数，包含上述若干种参数：
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

6. 函数参数
1) Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
2) 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
3) 要注意定义可变参数和关键字参数的语法：
(1) *args是可变参数，args接收的是一个tuple；
(2) **kw是关键字参数，kw接收的是一个dict
4) 以及调用函数时如何传入可变参数和关键字参数的语法：
(1) 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
(2) 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
5) 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
6) 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
7) 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

7. 递归函数
以求n的阶乘n!为例：
    def fact(n):
        if n==1:
            return 1
        return n * fact(n - 1)
1) 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
2) 使用递归函数需要注意防止栈溢出。
   在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
   由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
3) 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
4) 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
   这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
    def fact(n):
        return fact_iter(n, 1)

    def fact_iter(num, product):
        if num == 1:
            return product
        return fact_iter(num - 1, num * product)
   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。
5) 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
   遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
6) 小结
(1) 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
(2) 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
(3) Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

8. 
当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，
因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
1) 我们可以用命令行运行hello.py看看效果：
    $ python3 hello.py
    Hello, world!
2) 如果启动Python交互环境，再导入hello模块：
    $ python3
    Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
    [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import hello
    >>>
   导入时，没有打印Hello, word!，因为没有执行test()函数。
   调用hello.test()时，才能打印出Hello, word!：
    >>> hello.test()
    Hello, world!
