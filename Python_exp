1. Python 中没有变量声明的过程，使用时直接初始化（声明+赋值），以为Python是以真实值为基准，而变量名是指向该值的指针。

2. 可更改(mutable)与不可更改(immutable)对象
1) 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
(1) 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
(2) 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
2) python 函数的参数传递：
(1) 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。
    比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
(2) 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响
3) python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

3. 什么是可变/不可变对象
1) 不可变对象，该对象所指向的内存中的值不能被改变。
当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。
2) 可变对象，该对象所指向的内存中的值可以被改变。
变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。
3) Python中，数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。

4. 序列 & 字典
序列是以连续的整数为索引，如列表，元组。
字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
(1) 理解字典的最佳方式是把它看做无序的键=>值对集合。
(2) 在同一个字典之内，关键字必须是互不相同。
(3) 一对大括号创建一个空的字典：{}。

5. 参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。
但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
比如定义一个函数，包含上述若干种参数：
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

6. 函数参数
1) Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
2) 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
3) 要注意定义可变参数和关键字参数的语法：
(1) *args是可变参数，args接收的是一个tuple；
(2) **kw是关键字参数，kw接收的是一个dict
4) 以及调用函数时如何传入可变参数和关键字参数的语法：
(1) 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
(2) 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
5) 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
6) 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
7) 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

7. 递归函数
以求n的阶乘n!为例：
    def fact(n):
        if n==1:
            return 1
        return n * fact(n - 1)
1) 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
2) 使用递归函数需要注意防止栈溢出。
   在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
   由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
3) 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
4) 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
   这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
    def fact(n):
        return fact_iter(n, 1)

    def fact_iter(num, product):
        if num == 1:
            return product
        return fact_iter(num - 1, num * product)
   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。
5) 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
   遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
6) 小结
(1) 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
(2) 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
(3) Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

8. __name__变量的使用
当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，
因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
1) 我们可以用命令行运行hello.py看看效果：
    $ python3 hello.py
    Hello, world!
2) 如果启动Python交互环境，再导入hello模块：
    $ python3
    Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
    [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import hello
    >>>
   导入时，没有打印Hello, word!，因为没有执行test()函数。
   调用hello.test()时，才能打印出Hello, word!：
    >>> hello.test()
    Hello, world!
3) 也可以直接在模块中加入函数调用语句进行测试，如：test()。
   但模块通常被其他程序调用，其内部不应包含测试输出的语句。
   因而在模块代码末使用如下语句：
    if __name__=='__main__':
        test()
   即可在命令行环境中测试运行该模块的函数功能，也可在该模块被引用时避免执行测试输出的语句。
   
9. 面向对象编程
1) 面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。
   OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。
2) 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。
   为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
3) 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，
   计算机程序的执行就是一系列消息在各个对象之间传递。
4) 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。
   自定义的对象数据类型就是面向对象中的类（Class）的概念。
5) 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是这种数据类型应该被视为一个对象，这个对象拥有哪些属性（Property）。
   给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。
6) 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。
   Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，
   而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。
7) 所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。
8) 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。
9) 数据封装、继承和多态是面向对象的三大特点。
10) 封装性：针对类的属性变量而言；继承和多态性：针对类的方法函数而言。

10. 类和实例
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，
而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

11. 定义方法
仍以Student类为例，在Python中，定义类是通过class关键字：
    class Student(object):
        pass
1) class后面紧接着是类名，即Student，类名通常是大写开头的单词，
2) 紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，
   通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
3) 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过“ClassName()”实现的：
    >>> bart = Student()
    >>> bart
    <__main__.Student object at 0x10a67a590>
    >>> Student
    <class '__main__.Student'>
   可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。
4) 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：
    >>> bart.name = 'Bart Simpson'
    >>> bart.name
    'Bart Simpson'
5) 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。
   通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：
    class Student(object):

        def __init__(self, name, score):
            self.name = name
            self.score = score
6) 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，
   因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
7) 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，
   但self不需要传，Python解释器自己会把实例变量传进去：
8) 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。
   除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。

12. 数据封装
1) 面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，
   但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，
   这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：
2) 要定义一个方法，除了第一个参数是self外，其他和普通函数一样。
   要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：
3) 这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，
   而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
4) 封装的另一个好处是可以给Student类增加新的方法，
5) 小结
(1) 类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
(2) 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
(3) 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
(4) 和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：

13. 访问限制
1) 在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。
   但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：
2) 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，
   在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，
3) 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。
   但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：
   如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：
   为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：
4) 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，
   特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
5) 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，
   但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
6) 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。
   不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，
   所以，仍然可以通过_Student__name来访问__name变量：
7) 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。
   总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。

14. 继承和多态
1) 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），
   而被继承的class称为基类、父类或超类（Base class、Super class）。
2) 继承有什么好处？最大的好处是子类获得了父类的全部功能。
   由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：
3) 继承的第二个好处需要我们对代码做一点改进。
   当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。
   这样，我们就获得了继承的另一个好处：多态。
4) 要理解什么是多态，我们首先要对数据类型再作一点说明。
   当我们定义一个class的时候，我们实际上就定义了一种数据类型。
   我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：
    a = list() # a是list类型
    b = Animal() # b是Animal类型
    c = Dog() # c是Dog类型
   判断一个变量是否是某个类型可以用isinstance()判断：
    >>> isinstance(a, list)
    True
    >>> isinstance(b, Animal)
    True
    >>> isinstance(c, Dog)
    True
5) 但是等等，试试：
    >>> isinstance(c, Animal)
    True
   看来c不仅仅是Dog，c还是Animal！
6) 不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，
   当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！
7) 所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。
   但是，反过来就不行：
    >>> b = Animal()
    >>> isinstance(b, Dog)
    False
   Dog可以看成Animal，但Animal不可以看成Dog。
8) 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：
    def run_twice(animal):
        animal.run()
        animal.run()
   你会发现，新增一个Animal的子类，在任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
9) 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，
   因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。
   由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：
10) 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，
    而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，
    这就是多态真正的威力：调用方只管调用，不管细节，
    而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。
    这就是著名的“开闭”原则：
    (1) 对扩展开放：允许新增Animal子类；
    (2) 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。
11) 前提是父类、子类中含有相同名称的方法，才会在使用具体对象或函数调用时触发其多态性，即多态性是相对类的方法而言的一种特性
12) 继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。
    而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。
13) 小结
(1) 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
(2) 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。

15. 静态语言 vs 动态语言
1) 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
2) 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：
3) 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。
4) Python的“file-like object“就是一种鸭子类型。
   对真正的文件对象，它有一个read()方法，返回其内容。
   但是，许多对象，只要有read()方法，都被视为“file-like object“。
   许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。

16. 获取对象信息
当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？
1) 使用type()
   首先，我们来判断对象类型，使用type()函数：
   基本类型都可以用type()判断：
   如果一个变量指向函数或者类，也可以用type()判断：
2) 但是type()函数返回的是什么类型呢？
   它返回对应的Class类型。
   如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：
   判断基本数据类型可以直接写int，str等，
3) 但如果要判断一个对象是否是函数怎么办？
   可以使用types模块中定义的常量：
    >>> import types
    >>> def fn():
    ...     pass
    ...
    >>> type(fn) == types.FunctionType
    True
    >>> type(abs) == types.BuiltinFunctionType
    True
    >>> type(lambda x: x) == types.LambdaType
    True
    >>> type((x for x in range(10))) == types.GeneratorType
    True
4) 使用isinstance()
   对于class的继承关系来说，使用type()就很不方便。
   我们要判断class的类型，可以使用isinstance()函数。
   换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。
   能用type()判断的基本类型也可以用isinstance()判断：
   并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：
    >>> isinstance([1, 2, 3], (list, tuple))
    True
    >>> isinstance((1, 2, 3), (list, tuple))
    True
   总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。
5) 使用dir()
   如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：
    >>> dir('ABC')
    ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
   类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。
   在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，
   所以，下面的代码是等价的：
    >>> len('ABC')
    3
    >>> 'ABC'.__len__()
    3
   剩下的都是普通属性或方法，比如lower()返回小写的字符串：
6) 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：
   紧接着，可以测试该对象的属性：
    >>> hasattr(obj, 'x') # 有属性'x'吗？
    True
    >>> obj.x
    9
    >>> hasattr(obj, 'y') # 有属性'y'吗？
    False
    >>> setattr(obj, 'y', 19) # 设置一个属性'y'
    >>> hasattr(obj, 'y') # 有属性'y'吗？
    True
    >>> getattr(obj, 'y') # 获取属性'y'
    19
    >>> obj.y # 获取属性'y'
    19
   如果试图获取不存在的属性，会抛出AttributeError的错误：
   可以传入一个default参数，如果属性不存在，就返回默认值：
    >>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
    404
   也可以获得对象的方法：
7) 小结
(1) 通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。
    要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：
    sum = obj.x + obj.y
    就不要写：
    sum = getattr(obj, 'x') + getattr(obj, 'y')
(2) 一个正确的用法的例子如下：
    def readImage(fp):
        if hasattr(fp, 'read'):
            return readData(fp)
        return None
    假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。
    hasattr()就派上了用场。
(3) 请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，
    但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。

17. 实例属性和类属性
1) 由于Python是动态语言，根据类创建的实例可以任意绑定属性。
   给实例绑定属性的方法是通过实例变量，或者通过self变量：
    class Student(object):
        def __init__(self, name):
            self.name = name

    s = Student('Bob')
    s.score = 90
 2) 但是，如果Student类本身需要绑定一个属性呢？
    可以直接在class中定义属性，这种属性是类属性，归Student类所有：
    class Student(object):
        name = 'Student'
   当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。
