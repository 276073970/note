1. Python 中没有变量声明的过程，使用时直接初始化（声明+赋值），以为Python是以真实值为基准，而变量名是指向该值的指针。

2. 可更改(mutable)与不可更改(immutable)对象
1) 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
(1) 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
(2) 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
2) python 函数的参数传递：
(1) 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。
    比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
(2) 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响
3) python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

3. 什么是可变/不可变对象
1) 不可变对象，该对象所指向的内存中的值不能被改变。
当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。
2) 可变对象，该对象所指向的内存中的值可以被改变。
变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。
3) Python中，数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。

4. 序列 & 字典
序列是以连续的整数为索引，如列表，元组。
字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
(1) 理解字典的最佳方式是把它看做无序的键=>值对集合。
(2) 在同一个字典之内，关键字必须是互不相同。
(3) 一对大括号创建一个空的字典：{}。

5. 参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。
但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
比如定义一个函数，包含上述若干种参数：
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

6. 函数参数
1) Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
2) 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
3) 要注意定义可变参数和关键字参数的语法：
(1) *args是可变参数，args接收的是一个tuple；
(2) **kw是关键字参数，kw接收的是一个dict
4) 以及调用函数时如何传入可变参数和关键字参数的语法：
(1) 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
(2) 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
5) 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
6) 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
7) 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

7. 递归函数
以求n的阶乘n!为例：
    def fact(n):
        if n==1:
            return 1
        return n * fact(n - 1)
1) 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
2) 使用递归函数需要注意防止栈溢出。
   在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
   由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
3) 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
4) 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
   这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
    def fact(n):
        return fact_iter(n, 1)

    def fact_iter(num, product):
        if num == 1:
            return product
        return fact_iter(num - 1, num * product)
   可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。
5) 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
   遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
6) 小结
(1) 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
(2) 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
(3) Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

8. __name__变量的使用
当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，
因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
1) 我们可以用命令行运行hello.py看看效果：
    $ python3 hello.py
    Hello, world!
2) 如果启动Python交互环境，再导入hello模块：
    $ python3
    Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
    [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import hello
    >>>
   导入时，没有打印Hello, word!，因为没有执行test()函数。
   调用hello.test()时，才能打印出Hello, word!：
    >>> hello.test()
    Hello, world!
3) 也可以直接在模块中加入函数调用语句进行测试，如：test()。
   但模块通常被其他程序调用，其内部不应包含测试输出的语句。
   因而在模块代码末使用如下语句：
    if __name__=='__main__':
        test()
   即可在命令行环境中测试运行该模块的函数功能，也可在该模块被引用时避免执行测试输出的语句。
   
9. 面向对象编程
1) 面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。
   OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。
2) 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。
   为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
3) 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，
   计算机程序的执行就是一系列消息在各个对象之间传递。
4) 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。
   自定义的对象数据类型就是面向对象中的类（Class）的概念。
5) 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是这种数据类型应该被视为一个对象，这个对象拥有哪些属性（Property）。
   给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。
6) 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。
   Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，
   而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。
7) 所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。
8) 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。
9) 数据封装、继承和多态是面向对象的三大特点。

10. 类和实例
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，
而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

11. 定义方法
1) 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，
   因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
2) 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，
   但self不需要传，Python解释器自己会把实例变量传进去：
3) 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。
   除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。

12. 数据封装
1) 面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，
   但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，
   这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：
2) 要定义一个方法，除了第一个参数是self外，其他和普通函数一样。
   要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：
3) 这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，
   而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
4) 封装的另一个好处是可以给Student类增加新的方法，
5) 小结
(1) 类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
(2) 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
(3) 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
(4) 和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：

13. 
