====================================================================================================
========== 配置环境变量 ==============================================================================
====================================================================================================
[root@localhost ~]# vi /etc/profile

export JAVA_HOME=/usr/local/share/jdk1.8.0_131
export CATALINA_HOME=/usr/local/share/apache-tomcat-8.5.14
export CATALINA_BASE=/usr/local/share/apache-tomcat-8.5.14
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib

[root@localhost ~]# source /etc/profile

http://192.168.1.123:8080（验证）

注意问题：
linux 环境变量不小心被改了几乎所有的基本命令（ls,vi 等）都不能用了，怎么改回来？
解决方法：
一般重新启动下就好了。
也可以用命令：
export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
但是只对对当前会话窗口有用。

环境变量配置 (Python)
程序和可执行文件可以在许多目录，而这些路径很可能不在操作系统提供可执行文件的搜索路径中。
path(路径)存储在环境变量中，这是由操作系统维护的一个命名的字符串。这些变量包含可用的命令行解释器和其他程序的信息。
Unix或Windows中路径变量为PATH（UNIX区分大小写，Windows不区分大小写）。
在Mac OS中，安装程序过程中改变了python的安装路径。如果你需要在其他目录引用Python，你必须在path中添加Python目录。
在 Unix/Linux 设置环境变量
(1) 在 csh shell 输入:
    setenv PATH "$PATH:/usr/local/bin/python"
(2) 在 bash shell (Linux) 输入:
    export PATH="$PATH:/usr/local/bin/python" 
(3) 在 sh 或者 ksh shell 输入:
    PATH="$PATH:/usr/local/bin/python" 
注意: /usr/local/bin/python 是 Python 的安装目录。

Kali Linux 2017.3

1. export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

2. 运行 file_name.py 的3种方式:
//
1) # python3 file_name.py (脚本式编程)
//
2) # ./file_name.py (脚本式编程)
(1) 在Linux/Unix系统中，可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：
#! /usr/bin/env python3
(2) 然后修改脚本权限，使其有执行权限，命令如下：
# chmod +x file_name.py
//
3) # python3 (交互式编程, 各行以"Enter"结束)
(1) 版本: python3 --version
(2) 退出: exit() 或 Ctrl-D
(3) 查看其他信息:
help() (quit退出)
copyright()
credits()
license() (q退出)

3. #! /usr/bin/python3
1) 在 Windows 下可以不写第一行注释
2) 第一行注释标的是指向 python 的路径，告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器。
3) 此外还有以下形式（推荐写法）: #! /usr/bin/env python3
这种用法先在 env（环境变量）设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。

4. /usr/bin/ (Python安装目录)
-rwxr-xr-x  1 root root        7806 Oct 26 15:09  py3clean
-rwxr-xr-x  1 root root       12113 Oct 26 15:09  py3compile
lrwxrwxrwx  1 root root          31 Nov 22 06:54  py3versions -> ../share/python3/py3versions.py
-rwxr-xr-x  1 root root          60 Sep 25 20:06  pyalacarte
-rwxr-xr-x  1 root root          59 Sep 25 20:06  pyalamode
lrwxrwxrwx  1 root root          26 Nov 22 06:54  pybuild -> ../share/dh-python/pybuild
-rwxr-xr-x  1 root root        4123 Sep 18 04:17  pyclean
-rwxr-xr-x  1 root root       11894 Sep 18 04:17  pycompile
-rwxr-xr-x  1 root root          57 Sep 25 20:06  pycrust
lrwxrwxrwx  1 root root           8 Nov 22 06:48  pydoc -> pydoc2.7
-rwxr-xr-x  1 root root          79 Sep 17 14:50  pydoc2.7
lrwxrwxrwx  1 root root           8 Nov 22 06:48  pydoc3 -> pydoc3.6
-rwxr-xr-x  1 root root          79 Oct  3 17:16  pydoc3.6
lrwxrwxrwx  1 root root          12 Nov 22 06:48  pygettext -> pygettext2.7
-rwxr-xr-x  1 root root       22096 Sep 17 14:50  pygettext2.7
lrwxrwxrwx  1 root root          12 Nov 22 06:48  pygettext3 -> pygettext3.6
-rwxr-xr-x  1 root root       21098 Oct  3 17:16  pygettext3.6
-rwxr-xr-x  1 root root         148 Jan 23  2017  pygmentize
-rwxr-xr-x  1 root root         391 Sep 26 17:25  pyhtmlizer
-rwxr-xr-x  1 root root         289 Jan 10  2017  pyrit
-rwxr-xr-x  1 root root          57 Sep 25 20:06  pyshell
-rwxr-xr-x  1 root root        5443 May 21  2012  pysnmpbulkwalk
-rwxr-xr-x  1 root root        2571 May 21  2012  pysnmpget
-rwxr-xr-x  1 root root        2575 May 21  2012  pysnmpset
-rwxr-xr-x  1 root root        6295 May 21  2012  pysnmptranslate
-rwxr-xr-x  1 root root        8396 May 21  2012  pysnmptrap
-rwxr-xr-x  1 root root        4784 May 21  2012  pysnmpwalk
-rwxr-xr-x  1 root root         376 Sep  4 06:13  pytest
lrwxrwxrwx  1 root root           6 Nov 22 06:48  py.test -> pytest
lrwxrwxrwx  1 root root           9 Nov 22 06:48  python -> python2.7
lrwxrwxrwx  1 root root           9 Nov 22 06:48  python2 -> python2.7
-rwxr-xr-x  1 root root     3701568 Sep 17 14:50  python2.7
lrwxrwxrwx  1 root root          33 Nov 22 06:48  python2.7-config -> x86_64-linux-gnu-python2.7-config
lrwxrwxrwx  1 root root          16 Nov 22 06:48  python2-config -> python2.7-config
-rwxr-xr-x  1 root root         383 Sep 23  2016  python2-futurize
-rwxr-xr-x  1 root root         387 Sep 23  2016  python2-pasteurize
-rwxr-xr-x  1 root root         285 Aug 22  2016  python2-qr
lrwxrwxrwx  1 root root           9 Nov 22 06:48  python3 -> python3.6
-rwxr-xr-x  2 root root     4568920 Oct  3 17:16  python3.6
-rwxr-xr-x  2 root root     4568920 Oct  3 17:16  python3.6m
lrwxrwxrwx  1 root root          10 Nov 22 06:48  python3m -> python3.6m
-rwxr-xr-x  1 root root        5695 Sep  8  2016  python3-wsdump
-rwxr-xr-x  1 root root        2554 Jan 24  2017  python-argcomplete-check-easy-install-script
-rwxr-xr-x  1 root root         314 Jan 19  2017  python-argcomplete-tcsh
lrwxrwxrwx  1 root root          16 Nov 22 06:48  python-config -> python2.7-config
-rwxr-xr-x  1 root root         130 Nov 20 11:16  python-faraday
lrwxrwxrwx  1 root root          29 Nov 22 06:54  pyversions -> ../share/python/pyversions.py
-rwxr-xr-x  1 root root          56 Sep 25 20:06  pywrap
-rwxr-xr-x  1 root root          60 Sep 25 20:06  pywxrc

5. sh/bash/csh/Tcsh/ksh/pdksh等shell的区别
1) sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。
Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。
2) bash（全称 Bourne Again Shell）: Linux OS 默认的，它是 Bourne Shell 的扩展。
与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。
它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。
3) csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。
4) Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。
Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，
他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。
5) ksh (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。
6) pdksh: 是 Linux 系统提供的 ksh 的扩展。pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。

6. Linux/Unix & Windows 区别
1) Linux/Unix的系统上，一般默认的 python 版本为 2.x，我们可以将 python3.x 安装在 /usr/local/python3 目录中。
安装完成后，我们可以将路径 /usr/local/python3/bin 添加到您的 Linux/Unix 操作系统的环境变量中，
这样您就可以通过 shell 终端输入下面的命令来启动 Python3 。
$ PATH=$PATH:/usr/local/python3/bin/python3    # 设置环境变量
$ python3 --version
Python 3.4.0
2) 在Window系统下你可以通过以下命令来设置Python的环境变量，假设你的Python安装在 C:\Python34 下:
set path=%path%;C:\python34

====================================================================================================
========== 注释风格 =================================================================================
====================================================================================================
确保对模块, 函数, 方法和行内注释使用正确的风格。Python中的注释有单行注释和多行注释:

1. 单行注释: 
以 # 开头，如：
# 这是一个单行注释

2. 多行注释:
1) 三个单引号(''')将注释括起来，如：
'''
这是多行注释，用三个单引号
这是多行注释，用三个单引号
这是多行注释，用三个单引号
'''
2) 三个双引号(""")将注释括起来，如：
"""
这是多行注释，用三个双引号
这是多行注释，用三个双引号 
这是多行注释，用三个双引号
"""
====================================================================================================
========== 多行语句 =================================================================================
====================================================================================================
1. 多行语句
Python 通常是一行写完一条语句，但如果语句很长:
1) 使用反斜杠(\)来实现多行语句，例如：
total = item_one + \
        item_two + \
        item_three
2) 在 [], {}, 或 () 中的多行语句, 不需要使用反斜杠(\)，例如：
total = ['item_one', 'item_two', 'item_three',
        'item_four', 'item_five']

2. 字符串
1) Python中单引号和双引号使用完全相同。
2) 使用三引号('''或""")可以指定一个多行字符串，例如：
string = """This is a 
         String"""
3) 转义符 '\' ，例如：
print("Hello World!\n")
4) 自然字符串，在字符串前加r或R，例如：
print(r"this is a line with \n")
则\n会直接显示，并不是换行。
5) Python允许处理unicode字符串，加前缀u或U，例如：
print(u"this is an unicode string")
6) 字符串是不可变的。
7) 按字面意义级联字符串，如"this " "is " "string"会被自动转换为this is string。

3. 同一行显示多条语句
Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：
#! /usr/bin/python3
import sys; x = 'runoob'; sys.stdout.write(x + '\n')

4. 多个语句构成代码组
缩进相同的一组语句构成一个代码块，我们称之代码组。
像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
我们将首行及后面的代码组称为一个子句(clause)。
如下实例：
if expression : 
   suite
elif expression : 
   suite 
else : 
   suite
   
5. 数据类型
python中数有四种类型：整数、长整数、浮点数和复数。
1) 整数， 如 1
2) 长整数 是比较大的整数
3) 浮点数 如 1.23、3E-2
4) 复数 如 1 + 2j、 1.1 + 2.2j

====================================================================================================
========== 运算符 ===================================================================================
====================================================================================================
以下表格列出了从最高到最低优先级的所有运算符：
[运算符]       [描述]
**            指数 (最高优先级)
~, +, -       按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
*, /, %, //   乘，除，取模和取整除
+, -          加法减法
>>, <<        右移, 左移运算符
&             位 'AND'
^, |          位运算符
<=, <, >, >=  比较运算符
<>, ==, !=    等于运算符
=, %=, /=, //=, -=, +=, *=, **=     赋值运算符
is, is not    身份运算符
in, not in    成员运算符
not, or, and  逻辑运算符

python 中:
and : 从左到右计算表达式, 若所有值均为真, 则返回最后一个值; 若存在假, 返回False;
or  : 从左到有计算表达式, 若所有值均为假, 则返回False; 若存在真, 返回第一个为真的值；
其中:
数字 0 是假, 其他都是真;
字符 "" 是假, 其他都是真;

====================================================================================================
========== 问题总结 =================================================================================
====================================================================================================
1. Python 不识别 a++ 语句
刚开始学 python，当想要自增运算的时候很自然的 a++，结果发现编译器是不认识 ++ 的，
于是去网上搜了一下，结果发现一篇老外的问答很精彩，涉及到了 python 这个语言的设计原理。
问题无外乎就是 python 没有自增运算符，自增操作是如何实现的。
回答中有人介绍了关于自增操作，python 不使用 ++ 的哲学逻辑：编译解析上的简洁与语言本身的简洁，就不具体翻译了。
后面还有老外回答并附带了一个例子非常的精彩，指出了 python 与 c 语言概念上的一些差异，语言描述的可能未必准确，直接上例子：
>>> b = 5  
>>> a = 5  
>>> id(a)  
162334512  
>>> id(b)  
162334512  
>>> a is b  
True  
可以看出， python 中，变量是以内容为基准而不是像 c 中以变量名为基准，
所以只要你的数字内容是5，不管你起什么名字，这个变量的 ID 是相同的，
同时也就说明了 python 中一个变量可以以多个名称访问。
这样的设计逻辑决定了 python 中数字类型的值是不可变的，
因为如果如上例，a 和 b 都是 5，当你改变了 a 时，b 也会跟着变，这当然不是我们希望的。
因此，正确的自增操作应该 a = a + 1 或者 a += 1，当此 a 自增后，通过 id() 观察可知，id 值变化了，即 a 已经是新值的名称。
//
c语言中 a++ 运算速度最快，远快过 a=a+1 ，因为其计算逻辑最接近底层寄存器和运算单元的实现过程，即：
从寄存器中取值 => 在运算单元中加1 => 将加1后的新值写回原寄存器(覆盖)
但是在Python中，变量是以内容为基准而不是像 c 中以变量名为基准，即：
C 中每个变量对应一个专属的存储区； Python 中等值变量可对应同一个存储区，
因此注定 Python 中某变量自增1时，该变量名会指向其他存储区，而不是去改变原存储区中的值(因为这会导致同样指向该存储区的变量的值的改变)，
因此在 Python 中不会出现像 a++ 这样的自增语句。
